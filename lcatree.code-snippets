{
	"lca": {
  "prefix": "lca",
  "body": [
    "struct LCA{",
    "    int n;",
    "    vector<int> depth;",
    "    vector<vector<int>> adj;",
    "    vector<vector<int>> parent;",
    "    vector<int> euler;",
    "    vector<int> first_occurence;",
    "    int l;",
    "",
    "    template<typename T , class F = function<T(const T&,const T&)>>",
    "    struct SPARSE_TABLE{  ",
    "        int n;",
    "        vector<vector<T>> st;",
    "        F fun;",
    "    ",
    "        int log_floor(int x){",
    "            return x ? __builtin_clzll(1) - __builtin_clzll(x)  : -1 ;",
    "        }",
    "        SPARSE_TABLE(const vector<T> &v , const F &f) : fun(f){",
    "            n = static_cast<int>(v.size());",
    "            int maxN = log_floor(n) + 1;",
    "    ",
    "            st.resize(maxN);",
    "            st[0] = v;",
    "    ",
    "            for(int i = 1; i < maxN; i++){",
    "                st[i].resize(n - (1 << i) + 1);",
    "    ",
    "                for(int j = 0; j + (1 << i) <= n; j++){",
    "                    st[i][j] = fun(st[i - 1][j] , st[i - 1][j + (1 << (i - 1))]);",
    "                }",
    "            }",
    "        }",
    "    ",
    "        T get(int l, int r){",
    "            int h = log_floor(r - l + 1);",
    "            // works for idempotent functions only ykw",
    "            return fun(st[h][l] , st[h][r - (1 << h) + 1]);",
    "        }",
    "    };",
    "    SPARSE_TABLE<int> *st;",
    "",
    "    LCA(int n) : n(n){",
    "        n ++;",
    "        adj.resize(n);",
    "        depth.resize(n);",
    "        parent.resize(n);",
    "        l = 20;",
    "        // l = log_floor(n) + 1;",
    "        for(int i = 0; i < n; i++){",
    "            parent[i].resize(l);",
    "        }",
    "        n --;",
    "    }",
    "    void add_edge(int u, int v){",
    "        adj[u].push_back(v);",
    "        adj[v].push_back(u);",
    "    }",
    "    void dfs(int u, int p){",
    "        euler.push_back(u);",
    "        parent[u][0] = p;",
    "        for(int i = 1; i < l; i++){",
    "            parent[u][i] = parent[parent[u][i - 1]][i - 1];",
    "        }",
    "        for(auto v : adj[u]){",
    "            if(v == p) continue;",
    "            depth[v] = depth[u] + 1;",
    "            dfs(v, u);",
    "            euler.push_back(u);",
    "        }",
    "    }",
    "    void build(){",
    "        depth[0] = 0;",
    "        dfs(1, 0);",
    "        first_occurence.resize(n + 1, -1);",
    "        for(int i = 0; i < euler.size(); i++){",
    "            if(first_occurence[euler[i]] == -1){",
    "                first_occurence[euler[i]] = i;",
    "            }",
    "        }",
    "        vector<int> v;",
    "        for(auto x : euler){",
    "            v.push_back(depth[x]);",
    "        }",
    "        st = new SPARSE_TABLE<int>(v, [&](int a, int b){",
    "            return min(a, b);",
    "        });",
    "    }",
    "    int lcaDPTH(int u, int v){",
    "        // returns depth of lca",
    "        if(first_occurence[u] > first_occurence[v]){",
    "            swap(u, v);",
    "        }",
    "        return st->get(first_occurence[u], first_occurence[v]);",
    "    }",
    "    int dst(int u, int v){",
    "        return depth[u] + depth[v] - 2 * lcaDPTH(u, v);",
    "    }",
    "};"
  ],
  "description": "lca"
}
}