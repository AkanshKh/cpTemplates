{
	"segtree": {
  "prefix": "segtree",
  "body": [
    "// Always remember to use stl function plus<int>() instead of using lambda function if ",
    "// you are using plus operator in the function.",
    "template<typename T , class F = function<T(const T&,const T&)>>",
    "struct SegTree{",
    "    int n;",
    "    vector<T> a;",
    "    vector<T> sg;",
    "    F fun;",
    "    int toret = 0;",
    "",
    "    SegTree(const vector<T> &v, const F &f) : fun(f) {",
    "        n = static_cast<int>(v.size()) - 1;",
    "        sg.resize(4 * n + 5);",
    "        a.resize(v.size());",
    "        a = v;",
    "        // dbg(a)",
    "        toret = (fun(2, 3) == 2 ? inf : -inf);",
    "        Build(1, n, 1);",
    "    }",
    "",
    "    void Build(int st, int en, int node){",
    "        if(st == en){",
    "            sg[node] = a[st];",
    "            return;",
    "        }",
    "        int mid = (st + en) >> 1;",
    "        Build(st, mid, node << 1);",
    "        Build(mid + 1, en, node << 1 | 1);",
    "        sg[node] = fun(sg[node << 1], sg[node << 1 | 1]);",
    "    }",
    "",
    "    template<typename U = F>",
    "    typename enable_if<!is_same<U, plus<T>>::value, T>::type",
    "    Query(int node, int st, int en, int ql, int qr){",
    "        if(st > qr || en < ql){",
    "            return toret;",
    "        }",
    "        if(st >= ql && en <= qr){",
    "            return sg[node];",
    "        }",
    "        int mid = (st + en) >> 1;",
    "        return fun(Query(node << 1, st, mid, ql, qr), Query(node << 1 | 1, mid + 1, en, ql, qr));",
    "    }",
    "    ",
    "    template<typename U = F>",
    "    typename enable_if<is_same<U, plus<T>>::value, T>::type",
    "    Query(int node, int st, int en, int ql, int qr){",
    "        if(st > qr || en < ql){",
    "            return 0;",
    "        }",
    "        if(st == ql && en == qr){",
    "            return sg[node];",
    "        }",
    "        int mid = (st + en) >> 1;",
    "        return Query(node << 1, st, mid, ql, min(qr, mid)) + Query(node << 1 | 1, mid + 1, en, max(ql, mid + 1), qr);",
    "    }",
    "",
    "    void Update(int node, int st, int en, int idx, int val){",
    "        if(st == en){",
    "            sg[node] = val;",
    "            return;",
    "        }",
    "        int mid = (st + en) >> 1;",
    "        if(idx <= mid){",
    "            Update(node << 1, st, mid, idx, val);",
    "        }",
    "        else{",
    "            Update(node << 1 | 1, mid + 1, en, idx, val);",
    "        }",
    "        sg[node] = fun(sg[node << 1], sg[node << 1 | 1]);",
    "    }",
    "};",
    ""
  ],
  "description": "segtree"
}
}